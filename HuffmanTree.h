#pragma once
#include <map>
#include <optional>
#include <stdexcept>
#include <unordered_map>
#include <vector>

/*
 * The main part here is the algorithm " (last_generated_huffman_code + how_many_huffman_code_that_share_the_same_length_as_the_last_generated_huffman_code) << 1; " that ensure the huffman code that generated by the Length will never enter an ambiguous state.
 * This is done even if the length is zero.
 * Think this as an array, you need to know what index was the last chunk in the array, and how big was the last chunk. There after you can calculate the index for the new chunk.
 * Otherwise all other helper functions are just normal iterations.
*/

template <typename Code, typename Symbol, typename Length>
class HuffmanTree {
	struct HuffmanCode {
		Code code;
		Length length;
		bool operator<(const HuffmanCode& other) const {
			if (length != other.length)
				return length < other.length;
			return code < other.code;
		}
	};
public:
	HuffmanTree() = delete;
	HuffmanTree(const std::vector<Symbol>& symbols, const std::vector<Length>& lengths);
	std::optional<Symbol> Decode(Code code, Length length);
	Code Reverse_Bits(Code code, Length code_length);
	Length Minimum_Length();
private:
	size_t How_Many(const std::vector<Length>& lengths, Length ref);
	std::vector<std::optional<Code>> Generate_Canoncial_Huffman_Code(const std::vector<Length>& lengths);
	void Construct_Huffman_Tree(const std::vector<std::optional<Code>>& codes, const std::vector<Symbol>& symbols, const std::vector<Length>& lengths);
	Code Generate_The_First_Canoncial_Huffman_Code_With_This_Length(Code already_generated, size_t how_many_was_it);
	Length Find_Bigger_Any(const std::vector<Length>& lengths, Length anchor);
	Length Find_Lowest(const std::vector<Length>& lengths, Length bigger_than_this);
private:
	std::map<HuffmanCode, Symbol> m_tree;
	Length m_minimum_length_to_decode = 0u;
};

//*******************************************************************
// Member Functions
//*******************************************************************

/// <summary>
/// Canoncial huffman tree.
/// </summary>
/// <param name="lengths">: huffman code length</param>
template<typename Code, typename Symbol, typename Length>
inline HuffmanTree<Code, Symbol, Length>::HuffmanTree(const std::vector<Symbol>& symbols, const std::vector<Length>& lengths) {
	std::vector<std::optional<Code>> codes = Generate_Canoncial_Huffman_Code(lengths);
	Construct_Huffman_Tree(codes, symbols, lengths);
	m_minimum_length_to_decode = Find_Lowest(lengths, 0u);
}
/// <summary>
/// Decode the code using unordered_map.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline std::optional<Symbol> HuffmanTree<Code, Symbol, Length>::Decode(Code code, Length length) {
	HuffmanCode huffman_code;
	huffman_code.code = code;
	huffman_code.length = length;
	auto search = m_tree.find(huffman_code);
	if (search == m_tree.end()) {
		return std::nullopt;
	}
	return std::optional<Symbol>(search->second);
}
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Minimum_Length() {
	return m_minimum_length_to_decode;
}
/// <summary>
/// How many huffman code that share the same length.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline size_t HuffmanTree<Code, Symbol, Length>::How_Many(const std::vector<Length>& lengths, Length ref) {
	size_t counter = 0u;
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] == ref) {
			counter++;
		}
	}
	return counter;
}
/// <summary>
/// This starts with the huffman code that has the lowest length && first encountered in the Vector.
/// There is an algorithm this method follows here.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline std::vector<std::optional<Code>> HuffmanTree<Code, Symbol, Length>::Generate_Canoncial_Huffman_Code(const std::vector<Length>& lengths) {
	std::vector<std::optional<Code>> codes(lengths.size());
	Length the_length = 0u;
	Code the_code = 0u;
	size_t how_many = 0u;
	Length prev_length = 1u;
	do {
		prev_length = the_length;
		the_length = Find_Lowest(lengths, the_length);
		for (Length i = 0u; i < the_length - prev_length; i++) {
			the_code = Generate_The_First_Canoncial_Huffman_Code_With_This_Length(the_code, how_many);
			how_many = 0u;
		}
		if (the_length != 0u) {
			how_many = How_Many(lengths, the_length);
			size_t counter = 0u;
			for (size_t i = 0u; i < lengths.size(); i++) {
				if (lengths[i] == the_length) {
					codes[i] = the_code + counter;
					counter++;
				}
			}
		}
	} while (the_length != 0u);
	return codes;
}
/// <summary>
/// No calculations here. Just combines the result that other member function did.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline void HuffmanTree<Code, Symbol, Length>::Construct_Huffman_Tree(const std::vector<std::optional<Code>>& codes, const std::vector<Symbol>& symbols, const std::vector<Length>& lengths) {
	for (size_t i = 0u; i < codes.size(); i++) {
		if (codes[i] != std::nullopt) {
			HuffmanCode huffman_code;
			huffman_code.code = *(codes[i]);
			// huffman_code.code = *(codes[i]);
			huffman_code.length = lengths[i];
			m_tree[huffman_code] = symbols[i];
		}
	}
}
/// <summary>
/// Think this as array, you need to know what index was the last chunk, and how big was the last chunk.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Code HuffmanTree<Code, Symbol, Length>::Generate_The_First_Canoncial_Huffman_Code_With_This_Length(Code already_generated, size_t how_many_was_it) {
	return (already_generated + how_many_was_it) << 1;
}
template<typename Code, typename Symbol, typename Length>
inline Code HuffmanTree<Code, Symbol, Length>::Reverse_Bits(Code code, Length code_length) {
	Code result = 0;
	for (Length i = 0; i < code_length; i++) {
		if (code & (1 << i)) {
			result |= 1 << (code_length - 1 - i);
		}
	}
	return result;
}
/// <summary>
/// Returns the first Length encountered that bigger then the Anchor in a iteration.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Find_Bigger_Any(const std::vector<Length>& lengths, Length anchor) {
	Length bigger = 0u;
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] > anchor) {
			bigger = lengths[i];
			break;
		}
	}
	return bigger;
}
/// <summary>
/// Find_The_Lowest with lower bound.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Find_Lowest(const std::vector<Length>& lengths, Length bigger_than_this) {
	Length lowest = Find_Bigger_Any(lengths, bigger_than_this);
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] < lowest) {
			if (lengths[i] > bigger_than_this) {
				lowest = lengths[i];
			}
		}
	}
	return lowest;
}
