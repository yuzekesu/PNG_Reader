#pragma once
#include <map>
#include <optional>
#include <vector>

/*
 * The main part here is the algorithm " (last_generated_huffman_code + how_many_huffman_code_that_share_the_same_length_as_the_last_generated_huffman_code) << 1; " that ensure the huffman code that generated by the Length will never enter an ambiguous state.
 * This is done even if the length is zero.
 * Think this as an array, you need to know what index was the last chunk in the array, and how big was the last chunk. There after you can calculate the index for the new chunk.
 * Otherwise all other helper functions are just normal iterations.
*/

template <typename Code, typename Symbol, typename Length>
class HuffmanTree {
	struct HuffmanCode {
		Code code;
		Length length;
		bool operator<(const HuffmanCode& other) const {
			if (length != other.length)
				return length < other.length;
			return code < other.code;
		}
	};
public:
	HuffmanTree() = delete;
	HuffmanTree(const std::vector<Symbol>& symbols, const std::vector<Length>& lengths);
	std::optional<Symbol> Decode(Code code, Length length);
	Code Reverse_Bits(Code code, Length code_length);
	Length Minimum_Length();
private:
	size_t How_Many(const std::vector<Length>& lengths, Length ref);
	std::vector<std::optional<Code>> Generate_Canoncial_Huffman_Code(const std::vector<Length>& lengths);
	void Construct_Huffman_Tree(const std::vector<std::optional<Code>>& codes, const std::vector<Symbol>& symbols, const std::vector<Length>& lengths);
	Code Generate_The_First_Canoncial_Huffman_Code_With_This_Length(Code last_code_length, size_t how_many_was_sharing_the_same_length);
	Length Find_Bigger_Any(const std::vector<Length>& lengths, Length anchor);
	Length Find_Lowest(const std::vector<Length>& lengths, Length bigger_than_this);
private:
	std::map<HuffmanCode, Symbol> m_tree;
	Length m_minimum_length_to_decode = 0u;
};

//*******************************************************************
// Member Functions
//*******************************************************************

/// <summary>
/// generate canoncial huffman tree based on the length table and symbol table
/// </summary>
/// <param name="lengths">: huffman code length</param>
template<typename Code, typename Symbol, typename Length>
inline HuffmanTree<Code, Symbol, Length>::HuffmanTree(const std::vector<Symbol>& symbols, const std::vector<Length>& lengths) {
	std::vector<std::optional<Code>> codes = Generate_Canoncial_Huffman_Code(lengths);
	Construct_Huffman_Tree(codes, symbols, lengths);
	m_minimum_length_to_decode = Find_Lowest(lengths, 0u);
}
/// <summary>
/// decode the huffman code using and return the corresponding symbol
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline std::optional<Symbol> HuffmanTree<Code, Symbol, Length>::Decode(Code code, Length length) {
	/// the reason that we need the "length" is because of the padding
	/// when we read 1 bit and pass this to "Decode", the function cannot know if that is 1 bit or 8 bits since we dont have bit type in c++.
	HuffmanCode huffman_code;
	huffman_code.code = code;
	huffman_code.length = length;
	auto search = m_tree.find(huffman_code);
	if (search == m_tree.end()) {
		return std::nullopt;
	}
	return std::optional<Symbol>(search->second);
}
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Minimum_Length() {
	return m_minimum_length_to_decode;
}
/// <summary>
/// how many huffman code that share the same length.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline size_t HuffmanTree<Code, Symbol, Length>::How_Many(const std::vector<Length>& lengths, Length ref) {
	size_t counter = 0u;
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] == ref) {
			counter++;
		}
	}
	return counter;
}
/// <summary>
/// generate an vector of canoncial huffman codes based on the length table 
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline std::vector<std::optional<Code>> HuffmanTree<Code, Symbol, Length>::Generate_Canoncial_Huffman_Code(const std::vector<Length>& lengths) {
	/// This starts with the huffman code that has the lowest length && first encountered in the Vector.
	std::vector<std::optional<Code>> codes(lengths.size());
	Length the_length = 0u;
	Code the_code = 0u;
	size_t how_many = 0u;
	Length prev_length = 1u;
	do {
		prev_length = the_length;
		the_length = Find_Lowest(lengths, the_length);
		for (Length i = 0u; i < the_length - prev_length; i++) {
			the_code = Generate_The_First_Canoncial_Huffman_Code_With_This_Length(the_code, how_many);
			how_many = 0u;
		}
		if (the_length != 0u) {
			how_many = How_Many(lengths, the_length);
			size_t counter = 0u;
			for (size_t i = 0u; i < lengths.size(); i++) {
				if (lengths[i] == the_length) {
					codes[i] = the_code + counter;
					counter++;
				}
			}
		}
	} while (the_length != 0u);
	return codes;
}
/// <summary>
/// construct the "tree" using std::map.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline void HuffmanTree<Code, Symbol, Length>::Construct_Huffman_Tree(const std::vector<std::optional<Code>>& codes, const std::vector<Symbol>& symbols, const std::vector<Length>& lengths) {
	/// No calculations here. Just combines the result that other member function did.
	for (size_t i = 0u; i < codes.size(); i++) {
		if (codes[i] != std::nullopt) {
			HuffmanCode huffman_code;
			huffman_code.code = *(codes[i]);
			// huffman_code.code = *(codes[i]);
			huffman_code.length = lengths[i];
			m_tree[huffman_code] = symbols[i];
		}
	}
}
/// <summary>
/// generate the first canoncial huffman code that match this length based on the last generated code length.
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Code HuffmanTree<Code, Symbol, Length>::Generate_The_First_Canoncial_Huffman_Code_With_This_Length(Code last_code_length, size_t how_many_was_sharing_the_same_length) {
	/// the core of generating the canoncial huffman code
	return (last_code_length + how_many_was_sharing_the_same_length) << 1;
}
/// <summary>
/// reverse the bits inside the huffman code
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Code HuffmanTree<Code, Symbol, Length>::Reverse_Bits(Code code, Length code_length) {
	/// some of the compression might have reversed bitsstream, for example DEFLATE in .png
	Code result = 0;
	for (Length i = 0; i < code_length; i++) {
		if (code & (1 << i)) {
			result |= 1 << (code_length - 1 - i);
		}
	}
	return result;
}
/// <summary>
/// returns the first Length encountered that bigger then the Anchor in a iteration
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Find_Bigger_Any(const std::vector<Length>& lengths, Length anchor) {
	Length bigger = 0u;
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] > anchor) {
			bigger = lengths[i];
			break;
		}
	}
	return bigger;
}
/// <summary>
/// Find_The_Lowest with lower bound
/// </summary>
template<typename Code, typename Symbol, typename Length>
inline Length HuffmanTree<Code, Symbol, Length>::Find_Lowest(const std::vector<Length>& lengths, Length bigger_than_this) {
	Length lowest = Find_Bigger_Any(lengths, bigger_than_this);
	for (size_t i = 0u; i < lengths.size(); i++) {
		if (lengths[i] < lowest) {
			if (lengths[i] > bigger_than_this) {
				lowest = lengths[i];
			}
		}
	}
	return lowest;
}
